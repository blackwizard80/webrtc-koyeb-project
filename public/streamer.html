<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebRTC Streamer (Site A)</title>
    <style>
        #localVideo {
            width: 320px;
            height: 240px; 
            border: 1px solid red;
        }
    </style>
</head>
<body>
    <h1>Streamer (Site A) - කැමරාව යවන අඩවිය</h1>
    <video id="localVideo" autoplay playsinline muted></video>
    <p>Status: <span id="status">Connecting automatically...</span></p>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // ** Socket.IO Connection නිවැරදි කිරීම (Koyeb සඳහා) **
        const socket = io({
            path: '/socket.io/',
            transports: ['websocket']
        }); 
        
        const localVideo = document.getElementById('localVideo');
        const statusEl = document.getElementById('status');
        let localStream;
        let peerConnection; 
        let currentViewerId = null; // Offer එක යවන Viewer ගේ ID තබා ගැනීමට

        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        };

        async function startStream() {
            try {
                // ** Audio Track එක අනිවාර්යයෙන්ම ඉල්ලන්න (Autoplay Restriction මඟහරවා ගැනීමට) **
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                
                localVideo.srcObject = localStream;
                statusEl.textContent = 'Camera started. Waiting for Viewers...';
                
                socket.emit('join', 'streamer');
                
            } catch (error) {
                console.error('Error accessing media devices.', error);
                statusEl.textContent = `Error: ${error.name}. Camera access denied or HTTPS required.`;
            }
        }

        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(configuration);

            if (localStream) {
                // Video සහ Audio Tracks දෙකම Peer Connection එකට එකතු කරයි
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }
            
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // ICE Candidate එක යවන විට, එය targetViewerId එකට යවන්න
                    socket.emit('ice-candidate', { 
                        candidate: event.candidate, 
                        id: socket.id,
                        targetId: currentViewerId 
                    });
                }
            };
            
            peerConnection.onconnectionstatechange = () => {
                statusEl.textContent = `Connection State: ${peerConnection.connectionState}`;
            };
        }

        async function createOffer(targetViewerId) {
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                // Offer එක යවන විට Target ID එක ඇතුළත් කිරීම
                socket.emit('offer', { 
                    sdp: peerConnection.localDescription, 
                    id: socket.id,
                    targetId: targetViewerId 
                });
                statusEl.textContent = 'Offer sent. Waiting for Answer...';
            } catch (error) {
                console.error('Error creating offer:', error);
            }
        }
        
        // Viewers අලුතින් පැමිණි විට සම්බන්ධතාවය නැවත ගොඩනැගීම
        socket.on('viewer-ready', (viewerId) => {
            console.log(`New viewer (${viewerId}) is ready. Re-establishing connection.`);
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            currentViewerId = viewerId; // නවතම Viewer ID එක සටහන් කරගන්න
            createPeerConnection(); 
            createOffer(viewerId); // ලැබුණු viewerId එක Offer එකට යවන්න
        });

        socket.on('answer', async (data) => {
            if (peerConnection && !peerConnection.currentRemoteDescription) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                statusEl.textContent = 'Connected (Answer Received)';
            }
        });

        socket.on('ice-candidate', async (data) => {
            try {
                // ICE Candidate එකතු කිරීමට පෙර, එය මේ Streamer ගේ Peer Connection එකටදැයි පරීක්ෂා කිරීම අවශ්‍ය නැත.
                if (data.candidate && peerConnection && peerConnection.remoteDescription) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        });
        
        window.onload = startStream;
        
    </script>
</body>
</html>
